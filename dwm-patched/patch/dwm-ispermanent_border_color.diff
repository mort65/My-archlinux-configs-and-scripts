Common subdirectories: ../../dwm.bk/dwm/.git and ./.git
diff -up ../../dwm.bk/dwm/config.def.h ./config.def.h
--- ../../dwm.bk/dwm/config.def.h	2019-01-28 17:53:05.693891902 +0330
+++ ./config.def.h	2019-01-28 18:33:35.623853154 +0330
@@ -12,11 +12,11 @@ static const char col_gray2[]       = "#
 static const char col_gray3[]       = "#bbbbbb";
 static const char col_gray4[]       = "#eeeeee";
 static const char col_cyan[]        = "#005577";
-static const char *colors[][3]      = {
-	/*               fg         bg         border   */
-	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
-	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
-};
+static const char *colors[][4]      = {
+	/*               fg         bg         border     permanent */
+	[SchemeNorm] = { col_gray3, col_gray1, col_gray2, col_gray2 },
+	[SchemeSel] =  { col_gray4, col_cyan,  col_cyan, col_cyan },
+ };

 /* tagging */
 static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
@@ -26,9 +26,9 @@ static const Rule rules[] = {
 	 *	WM_CLASS(STRING) = instance, class
 	 *	WM_NAME(STRING) = title
 	 */
-	/* class      instance    title       tags mask     isfloating   monitor */
-	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
-	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
+	/* class      instance    title       tags mask     isfloating  ispermanent  monitor */
+	{ "Gimp",     NULL,       NULL,       0,            1,       0,       -1 },
+	{ "Firefox",  NULL,       NULL,       1 << 8,       0,      0,       -1 },
 };

 /* layout(s) */
@@ -78,6 +78,7 @@ static Key keys[] = {
 	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
 	{ MODKEY,                       XK_space,  setlayout,      {0} },
 	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
+	{ MODKEY,                       XK_n,      togglepermanent,{0} },
 	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
 	{ MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
 	{ MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
Only in .: config.h
diff -up ../../dwm.bk/dwm/drw.h ./drw.h
--- ../../dwm.bk/dwm/drw.h	2019-01-28 17:53:05.693891902 +0330
+++ ./drw.h	2019-01-28 18:34:44.913852049 +0330
@@ -12,7 +12,7 @@ typedef struct Fnt {
 	struct Fnt *next;
 } Fnt;

-enum { ColFg, ColBg, ColBorder }; /* Clr scheme index */
+enum { ColFg, ColBg, ColBorder, ColPermanent }; /* Clr scheme index */
 typedef XftColor Clr;

 typedef struct {
diff -up ../../dwm.bk/dwm/dwm.c ./dwm.c
--- ../../dwm.bk/dwm/dwm.c	2019-01-28 17:53:05.693891902 +0330
+++ ./dwm.c	2019-01-28 19:02:12.093825783 +0330
@@ -92,7 +92,7 @@ struct Client {
 	int basew, baseh, incw, inch, maxw, maxh, minw, minh;
 	int bw, oldbw;
 	unsigned int tags;
-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
+	int isfixed, ispermanent, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
 	Client *next;
 	Client *snext;
 	Monitor *mon;
@@ -138,6 +138,7 @@ typedef struct {
 	const char *title;
 	unsigned int tags;
 	int isfloating;
+	int ispermanent;
 	int monitor;
 } Rule;

@@ -211,6 +212,7 @@ static void tagmon(const Arg *arg);
 static void tile(Monitor *);
 static void togglebar(const Arg *arg);
 static void togglefloating(const Arg *arg);
+static void togglepermanent(const Arg *arg);
 static void toggletag(const Arg *arg);
 static void toggleview(const Arg *arg);
 static void unfocus(Client *c, int setfocus);
@@ -298,6 +300,7 @@ applyrules(Client *c)
 		&& (!r->instance || strstr(instance, r->instance)))
 		{
 			c->isfloating = r->isfloating;
+			c->ispermanent = r->ispermanent;
 			c->tags |= r->tags;
 			for (m = mons; m && m->num != r->monitor; m = m->next);
 			if (m)
@@ -795,8 +798,11 @@ focus(Client *c)
 		detachstack(c);
 		attachstack(c);
 		grabbuttons(c, 1);
-		XSetWindowBorder(dpy, c->win, scheme[SchemeSel][ColBorder].pixel);
-		setfocus(c);
+		if(c->ispermanent)
+			XSetWindowBorder(dpy, c->win, scheme[SchemeSel][ColPermanent].pixel);
+		else
+			XSetWindowBorder(dpy, c->win, scheme[SchemeSel][ColBorder].pixel);
+ 		setfocus(c);
 	} else {
 		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
 		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
@@ -1001,7 +1007,7 @@ keypress(XEvent *e)
 void
 killclient(const Arg *arg)
 {
-	if (!selmon->sel)
+	if(!selmon->sel || selmon->sel->ispermanent)
 		return;
 	if (!sendevent(selmon->sel, wmatom[WMDelete])) {
 		XGrabServer(dpy);
@@ -1051,7 +1057,10 @@ manage(Window w, XWindowAttributes *wa)

 	wc.border_width = c->bw;
 	XConfigureWindow(dpy, w, CWBorderWidth, &wc);
-	XSetWindowBorder(dpy, w, scheme[SchemeNorm][ColBorder].pixel);
+	if(c->ispermanent)
+		XSetWindowBorder(dpy, w, scheme[SchemeNorm][ColPermanent].pixel);
+	else
+		XSetWindowBorder(dpy, w, scheme[SchemeNorm][ColBorder].pixel);
 	configure(c); /* propagates border_width, if size doesn't change */
 	updatewindowtype(c);
 	updatesizehints(c);
@@ -1062,6 +1071,8 @@ manage(Window w, XWindowAttributes *wa)
 		c->isfloating = c->oldstate = trans != None || c->isfixed;
 	if (c->isfloating)
 		XRaiseWindow(dpy, c->win);
+	if(c->ispermanent)
+		XSetWindowBorder(dpy, w, scheme[SchemeNorm][ColPermanent].pixel);
 	attach(c);
 	attachstack(c);
 	XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
@@ -1569,7 +1580,7 @@ setup(void)
 	/* init appearance */
 	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
 	for (i = 0; i < LENGTH(colors); i++)
-		scheme[i] = drw_scm_create(drw, colors[i], 3);
+		scheme[i] = drw_scm_create(drw, colors[i], 4);
 	/* init bars */
 	updatebars();
 	updatestatus();
@@ -1719,6 +1730,19 @@ togglefloating(const Arg *arg)
 	arrange(selmon);
 }

+void
+togglepermanent(const Arg *arg)
+{
+	if (!selmon->sel)
+		return;
+	selmon->sel->ispermanent = !selmon->sel->ispermanent;
+	if (selmon->sel->ispermanent)
+		XSetWindowBorder(dpy, selmon->sel->win, scheme[SchemeSel][ColPermanent].pixel);
+	else {
+		XSetWindowBorder(dpy, selmon->sel->win, scheme[SchemeSel][ColBorder].pixel);
+		resizeclient(selmon->sel, selmon->sel->x, selmon->sel->y, selmon->sel->w, selmon->sel->h);
+	}
+	arrange(selmon);
+}
+
 void
 toggletag(const Arg *arg)
 {
